#!/bin/sh
# Copyright (C) 2011 O.S. Systems Software LTDA.
# Licensed on MIT

UPDATED_FLAG="updated"
FAIL_FLAG="failed"
DO_UPDATE_FLAG="do_update"
DO_APPLY_FLAG="do_apply"
UPDATE_DIR="/data/update/rootfs"
UPDATE_EXT="*.squashfs"

[[ -z $ROOTFS_DIR ]] && ROOTFS_DIR="/rootfs"

dmesg_msg() {
    #NOTE <3> is KERN_ERR loglevel, which cause alerts to be sent
    echo "<3>$1" > /dev/kmsg
}

finish_enabled() {
	return 0
}

do_switchroot() {
	echo "Moving /dev, /proc and /sys onto rootfs..."

	if grep -qs '/data ' /proc/mounts; then
		prepare_data
	fi

	mount --move /dev $ROOTFS_DIR/dev
	mount --move /proc $ROOTFS_DIR/proc
	mount --move /sys $ROOTFS_DIR/sys

	cd $ROOTFS_DIR
	exec switch_root -c /dev/console $ROOTFS_DIR ${bootparam_init:-/sbin/init}
}

prepare_data() {
	echo "Prepare rootfs"
	
	mkdir -p /data/etc/systemd/system/work
	[ "$(ls -A /data/etc/systemd/system/work)" ] && rm -rf /data/etc/systemd/system/work/*
	mkdir -p /data/etc/systemd/system/upper

	mkdir -p /data/home/work
	[ "$(ls -A /data/home/work)" ] && rm -rf /data/home/work/*
	mkdir -p /data/home/upper

	mount -t overlay overlay -o lowerdir=$ROOTFS_DIR/etc/systemd/system,workdir=/data/etc/systemd/system/work,upperdir=/data/etc/systemd/system/upper $ROOTFS_DIR/etc/systemd/system
	mount -t overlay overlay -o lowerdir=$ROOTFS_DIR/home/,workdir=/data/home/work,upperdir=/data/home/upper $ROOTFS_DIR/home

	mount --move /data $ROOTFS_DIR/var
}

switch_if_fail() {
	if [ $? -ne 0 ]; then
		dmesg_msg "Initramfs: $1"

		if grep -qs '/data ' /proc/mounts; then
			[[ -d $UPDATE_DIR ]] && touch $UPDATE_DIR/$FAIL_FLAG
		fi

		do_switchroot
	fi
}

mount_data() {
	mkdir -p /data
	mount -o defaults,usrjquota=aquota.user,jqfmt=vfsv0 $bootparam_userdata /data

	switch_if_fail "can't mount /data"

	rm -rf $UPDATE_DIR/$FAIL_FLAG
}

get_update_type() {
	local update=$(cat $UPDATE_DIR/$DO_UPDATE_FLAG)
	if [ -z $update ]; then
		echo "full"
	else
		echo $update
	fi
}

# Possible actions are: full, incremental, apply, ignore
get_action() {
	[[ -f "$UPDATE_DIR/$DO_APPLY_FLAG" ]] && {
		echo "apply"
		return
	}

	[[ -f "$UPDATE_DIR/$UPDATED_FLAG" ]] && {
		echo "ignore"
		return
	}

	[[ -f "$UPDATE_DIR/$DO_UPDATE_FLAG" ]] && {
		echo "$(get_update_type)"
		return
	}

	echo "ignore"
}

set_updated_part_flag() {
	echo "Set updated partition flag $UPDATE_DIR/$UPDATED_FLAG"
	touch $UPDATE_DIR/$UPDATED_FLAG
}

do_apply_update() {
	update_type="$(get_update_type)"
	update_file="$(find $UPDATE_DIR -name ${UPDATE_EXT} | head -n1)"

	[ ! -z $update_file ]
	switch_if_fail "update file not found"

	echo "Got update file $update_file"
	
	mkdir -p /update_layer
	mount $update_file /update_layer
	switch_if_fail "can't mount $update_file"

	mount -o remount,rw $ROOTFS_DIR
	switch_if_fail "can't remount rootfs"

	if [ x$update_type == x"full" ]; then
		echo "Apply full update"

		rm -rf $ROOTFS_DIR/*
		cp -rafd /update_layer/* $ROOTFS_DIR
		switch_if_fail "can't copy files"

		echo "Full update applied"
	else
		echo "Apply incremental update"

		cd /update_layer
		find ./* -type c -exec rm -rf $ROOTFS_DIR/{} \;
		find ./* -type d -exec mkdir -p {} $ROOTFS_DIR/{} \;
		find ./* -type f -exec cp -rafd {} $ROOTFS_DIR/{} \;
		cd -

		echo "Incremental update applied"
	fi

	umount /update_layer
	mount -o remount,ro $ROOTFS_DIR
}

do_mount_full_update() {
	update_file="$(find $UPDATE_DIR -name ${UPDATE_EXT} | head -n1)"

	[ ! -z $update_file ]
	switch_if_fail "update file not found"

	echo "Mount full update image $update_file"

	root_device=$(df -P $ROOTFS_DIR | tail -n 1 | awk '/.*/ { print $1 }')
	umount $ROOTFS_DIR

	mount -o ro $update_file $ROOTFS_DIR
	switch_if_fail "can't mount full image"
}

do_mount_inc_update() {
	update_file=$(find $UPDATE_DIR -name ${UPDATE_EXT} | head -n1)

	echo "Mount incremental update image $update_file"

	mkdir -p /update_layer

	mount $update_file /update_layer
	switch_if_fail "can't mount incremental image"

	mount -t overlay overlay -o lowerdir=/update_layer:$ROOTFS_DIR $ROOTFS_DIR
	switch_if_fail "can't mount incremental image"
}

finish_run() {
	if [ -n "$ROOTFS_DIR" ]; then
		if [ ! -d $ROOTFS_DIR/dev ]; then
			fatal "There's no '/dev' on rootfs."
		fi

		[[ -z $bootparam_userdata ]] && {
			echo "Userdata partition is not set, skipping initramfs"
			do_switchroot
		}

		mount_data

		info "Switching root to '$ROOTFS_DIR'..."

		action="$(get_action)"

		case "$action" in
		full)
			echo "Action: full"

			do_mount_full_update
			set_updated_part_flag
			;;
		incremental)
			echo "Action: incremental"

			do_mount_inc_update
			set_updated_part_flag
			;;
		apply)
			echo "Action: apply"

			do_apply_update
			;;
		ignore)
			echo "Action: ignoring update"
			;;
		*)
			echo "Fail: Unexpected action received- $action"
		esac

		do_switchroot
	else
		debug "No rootfs has been set"
	fi
}
